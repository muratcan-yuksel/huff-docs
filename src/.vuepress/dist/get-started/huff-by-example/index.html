<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Huff by Example | Huff Language</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Documentation for the Huff Language">
    <meta name="theme-color" content="#c70202">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.b0a66cc0.css" as="style"><link rel="preload" href="/assets/js/app.f80e70d4.js" as="script"><link rel="preload" href="/assets/js/2.fbc25f86.js" as="script"><link rel="preload" href="/assets/js/12.ff418896.js" as="script"><link rel="prefetch" href="/assets/js/10.10b20d65.js"><link rel="prefetch" href="/assets/js/11.0a86e14c.js"><link rel="prefetch" href="/assets/js/13.dbd310d9.js"><link rel="prefetch" href="/assets/js/14.f739287c.js"><link rel="prefetch" href="/assets/js/15.1d27754b.js"><link rel="prefetch" href="/assets/js/16.b8ce2f87.js"><link rel="prefetch" href="/assets/js/17.de757f34.js"><link rel="prefetch" href="/assets/js/18.15596483.js"><link rel="prefetch" href="/assets/js/19.1dae433e.js"><link rel="prefetch" href="/assets/js/20.76bad82f.js"><link rel="prefetch" href="/assets/js/21.21c7a29d.js"><link rel="prefetch" href="/assets/js/22.5f47afa2.js"><link rel="prefetch" href="/assets/js/23.4b38c2c8.js"><link rel="prefetch" href="/assets/js/24.da206082.js"><link rel="prefetch" href="/assets/js/25.4709b487.js"><link rel="prefetch" href="/assets/js/3.ccc119cc.js"><link rel="prefetch" href="/assets/js/4.0afa7f3a.js"><link rel="prefetch" href="/assets/js/5.75baa7dd.js"><link rel="prefetch" href="/assets/js/6.61d95085.js"><link rel="prefetch" href="/assets/js/7.bffed0f4.js"><link rel="prefetch" href="/assets/js/8.3e96e297.js"><link rel="prefetch" href="/assets/js/9.a12888d8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b0a66cc0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Huff Language</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/get-started/overview/" class="nav-link">
  Get Started
</a></div><div class="nav-item"><a href="/tutorial/overview/" class="nav-link">
  Tutorials
</a></div><div class="nav-item"><a href="/style-guide/overview/" class="nav-link">
  Style Guide
</a></div><div class="nav-item"><a href="/resources/overview/" class="nav-link">
  Resources
</a></div><div class="nav-item"><a href="/contribute/overview/" class="nav-link">
  Contribute
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/get-started/overview/" class="nav-link">
  Get Started
</a></div><div class="nav-item"><a href="/tutorial/overview/" class="nav-link">
  Tutorials
</a></div><div class="nav-item"><a href="/style-guide/overview/" class="nav-link">
  Style Guide
</a></div><div class="nav-item"><a href="/resources/overview/" class="nav-link">
  Resources
</a></div><div class="nav-item"><a href="/contribute/overview/" class="nav-link">
  Contribute
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Get Started</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/get-started/overview/" class="sidebar-link">Getting started</a></li><li><a href="/get-started/installing/" class="sidebar-link">Installing Huff</a></li><li><a href="/get-started/compiling/" class="sidebar-link">Compiling Contracts with the Huff Compiler</a></li><li><a href="/get-started/project-quickstart/" class="sidebar-link">Huff Project Template</a></li><li><a href="/get-started/huff-by-example/" aria-current="page" class="active sidebar-link">Huff by Example</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#introduction" class="sidebar-link">Introduction</a></li><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#defining-your-interface" class="sidebar-link">Defining your Interface</a></li><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#constants" class="sidebar-link">Constants</a></li><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#custom-errors" class="sidebar-link">Custom Errors</a></li><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#jump-labels" class="sidebar-link">Jump Labels</a></li><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#macros-and-functions" class="sidebar-link">Macros and Functions</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#macros" class="sidebar-link">Macros</a></li><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#functions" class="sidebar-link">Functions</a></li></ul></li><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#builtin-functions" class="sidebar-link">Builtin Functions</a></li><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#jump-tables" class="sidebar-link">Jump Tables</a></li><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#code-tables" class="sidebar-link">Code Tables</a></li><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#huff-tests" class="sidebar-link">Huff Tests</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/get-started/huff-by-example/#decorators" class="sidebar-link">Decorators</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="huff-by-example"><a href="#huff-by-example" class="header-anchor">#</a> Huff by Example</h1> <h2 id="introduction"><a href="#introduction" class="header-anchor">#</a> Introduction</h2> <p>Huff by Example is an effort to provide a thorough explanation of each
feature of the Huff language, along with code-snippet examples detailing how,
when, where, and why to use each one. The snippets here are heavily
commentated, but this section does assume some prior experience working
with the EVM.</p> <p>If you are new to low-level EVM programming, please read the
<a href="/tutorial/overview">Tutorials</a> section of the docs before diving into
Huff development. If you run into any issues, please feel free to come ask
the community questions on <a href="https://discord.gg/C3gTvkFNRR" target="_blank" rel="noopener noreferrer">Discord<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>!</p> <h2 id="defining-your-interface"><a href="#defining-your-interface" class="header-anchor">#</a> Defining your Interface</h2> <p>While defining an interface is not a necessary step, <code>functions</code> and <code>events</code>
can be defined in Huff contracts for two purposes: To be used as arguments
for the <code>__FUNC_SIG</code> and <code>__EVENT_HASH</code> builtins, and to generate a Solidity
Interface / Contract ABI.</p> <p>Functions can be of type <code>view</code>, <code>pure</code>, <code>payable</code> or <code>nonpayable</code>, and
function interfaces should only be defined for externally facing functions.</p> <p>Events can contain <code>indexed</code> and non-indexed values.</p> <h4 id="example"><a href="#example" class="header-anchor">#</a> Example</h4> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>#define function testFunction(uint256, bytes32) view returns (bytes memory)

#define event TestEvent(address indexed, uint256)
</code></pre></div><h2 id="constants"><a href="#constants" class="header-anchor">#</a> Constants</h2> <p>Constants in Huff contracts are not included in the contract's storage; Instead,
they are able to be called within the contract at compile time. Constants
can either be bytes (32 max) or a <code>FREE_STORAGE_POINTER</code>. A <code>FREE_STORAGE_POINTER</code>
constant will always represent an unused storage slot in the contract.</p> <p>In order to push a constant to the stack, use bracket notation: <code>[CONSTANT]</code></p> <h4 id="example-2"><a href="#example-2" class="header-anchor">#</a> Example</h4> <p><strong>Constant Declaration</strong></p> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>#define constant NUM = 0x420
#define constant HELLO_WORLD = 0x48656c6c6f2c20576f726c6421
#define constant FREE_STORAGE = FREE_STORAGE_POINTER()
</code></pre></div><p><strong>Constant Usage</strong>
(without loss of generality, let's say the constant <code>NUM</code> holds 0x420 from the above example)</p> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>                    // [] - an empty stack
[NUM]               // [0x420] - the constant's value is pushed to the stack
</code></pre></div><h2 id="custom-errors"><a href="#custom-errors" class="header-anchor">#</a> Custom Errors</h2> <p>Custom errors can be defined and used by the <code>__ERROR</code> builtin to push the left-padded 4 byte
error selector to the stack.</p> <h4 id="example-3"><a href="#example-3" class="header-anchor">#</a> Example</h4> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>// Define our custom error
#define error PanicError(uint256)
#define error Error(string)

#define macro PANIC() = takes (1) returns (0) {
    // Input stack:          [panic_code]
    __ERROR(PanicError)   // [panic_error_selector, panic_code]
    0x00 mstore           // [panic_code]
    0x04 mstore           // []
    0x24 0x00 revert
}

#define macro REQUIRE() = takes (3) returns (0) {
    // Input stack:          [condition, message_length, message]
    continue jumpi        // [message_length, message]

    __ERROR(Error)        // [error_selector, message_length, message]
    0x00 mstore           // [message_length, message]
    0x20 0x04 mstore      // [message_length, message]
    0x24 mstore           // [message]
    0x44 mstore           // []

    0x64 0x00 revert

    continue:
        pop               // []
}
</code></pre></div><h2 id="jump-labels"><a href="#jump-labels" class="header-anchor">#</a> Jump Labels</h2> <p>Jump Labels are a simple abstraction included into the language to make defining
and referring to <code>JUMPDEST</code>s more simple for the developer.</p> <h4 id="example-4"><a href="#example-4" class="header-anchor">#</a> Example</h4> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>#define macro MAIN() = takes (0) returns (0) {
    // Store &quot;Hello, World!&quot; in memory
    0x48656c6c6f2c20576f726c6421
    0x00 mstore // [&quot;Hello, World!&quot;]

    // Jump to success label, skipping the revert statement
    success     // [success_label_pc, &quot;Hello, World!&quot;]
    jump        // [&quot;Hello, World!&quot;]

    // Revert if this point is reached
    0x00 0x00 revert

    // Labels are defined within macros or functions, and are designated
    // by a word followed by a colon. Note that while it may appear as if
    // labels are scoped code blocks due to the indentation, they are simply
    // destinations to jump to in the bytecode. If operations exist below a label,
    // they will be executed unless the program counter is altered or execution is
    // halted by a `revert`, `return`, `stop`, or `selfdestruct` opcode.
    success:
        0x00 mstore
        0x20 0x00 return
}
</code></pre></div><h2 id="macros-and-functions"><a href="#macros-and-functions" class="header-anchor">#</a> Macros and Functions</h2> <p>Huff offers two ways to group together your bytecode: Macros and Functions. It is
important to understand the difference between the two, and when to use one
over the other.</p> <p>Both are defined similarly, taking optional arguments as well as being followed
by the <code>takes</code> and <code>returns</code> keywords. These designate the amount of stack
inputs the macro/function takes in as well as the amount of stack elements the
macro/function outputs. The <code>takes</code> and <code>returns</code> keywords are optional - if they are
not present, the value will default to <code>0</code>.</p> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>#define &lt;macro|fn&gt; TEST(err) = takes (1) returns (3) {
    // ...
}
</code></pre></div><h3 id="macros"><a href="#macros" class="header-anchor">#</a> Macros</h3> <p>Most of the time, Huff developers should opt to use macros. Each time a macro is invoked,
the code within it is placed at the point of invocation. This is efficient in
terms of runtime gas cost due to not having to jump to and from the macro's code,
but it can quickly increase the size of the contract's bytecode if it is used commonly
throughout.</p> <h4 id="constructor-and-main"><a href="#constructor-and-main" class="header-anchor">#</a> Constructor and Main</h4> <p><code>MAIN</code> and <code>CONSTRUCTOR</code> are two important macros that serve special purposes. When
your contract is called, the <code>MAIN</code> macro will be the fallback, and it is commonly where
a Huff contract's control flow begins. The <code>CONSTRUCTOR</code> macro, while not required,
can be used to initialize the contract upon deployment. Inputs to the <code>CONSTRUCTOR</code> macro
are provided at compile time.</p> <p>By default, the <code>CONSTRUCTOR</code> will add some bootstrap code that returns the compiled MAIN macro
as the contract's runtime bytecode. If the constructor contains a <code>RETURN</code> opcode, the compiler
will not include this bootstrap, and it will instead instantiate the contract with the code returned
by the constructor.</p> <h4 id="macro-arguments"><a href="#macro-arguments" class="header-anchor">#</a> Macro Arguments</h4> <p>Macros can accept arguments to be &quot;called&quot; inside the macro or passed as a reference. Macro arguments may be one of: label, opcode, literal, or a constant. Since macros are inlined at compile-time, the arguments are not evaluated at runtime and are instead inlined as well.</p> <h4 id="example-5"><a href="#example-5" class="header-anchor">#</a> Example</h4> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>// Define the contract's interface
#define function addWord(uint256) pure returns (uint256)

// Get a free storage slot to store the owner
#define constant OWNER = FREE_STORAGE_POINTER()

// Define the event we wish to emit
#define event WordAdded(uint256 initial, uint256 increment)

// Macro to emit an event that a word has been added
#define macro emitWordAdded(increment) = takes (1) returns (0) {
    // input stack: [initial]
    &lt;increment&gt;              // [increment, initial]
    __EVENT_HASH(WordAdded)  // [sig, increment, initial]
    0x00 0x00                // [mem_start, mem_end, sig, increment, initial]
    log3                     // []
}

// Only owner function modifier
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller                   // [msg.sender]
    [OWNER] sload            // [owner, msg.sender]
    eq                       // [owner == msg.sender]
    is_owner jumpi           // []

    // Revert if the sender is not the owner
    0x00 0x00 revert

    is_owner:
}

// Add a word (32 bytes) to a uint 
#define macro ADD_WORD() = takes (1) returns (1) {
    // Input Stack:          // [input_num]

    // Enforce that the caller is the owner. The code of the
    // `ONLY_OWNER` macro will be pasted at this invocation. 
    ONLY_OWNER()

    // Call our helper macro that emits an event when a word is added
    // Here we pass a literal that represents how much we increment the word by.
    // NOTE: We need to duplicate the input number on our stack since
    //       emitWordAdded takes 1 stack item and returns 0
    dup1                     // [input_num, input_num]
    emitWordAdded(0x20)      // [input_num]

    // NOTE: 0x20 is automatically pushed to the stack, it is assumed to be a 
    // literal by the compiler.
    0x20                     // [0x20, input_num]
    add                      // [0x20 + input_num]

    // Return stack:            [0x20 + input_num]
}

#define macro MAIN() = takes (0) returns (0) {
    // Get the function signature from the calldata
    0x00 calldataload        // [calldata @ 0x00]
    0xE0 shr                 // [func_sig (calldata @ 0x00 &gt;&gt; 0xE0)]

    // Check if the function signature in the calldata is
    // a match to our `addWord` function definition.
    // More about the `__FUNC_SIG` builtin in the `Builtin Functions`
    // section.
    __FUNC_SIG(addWord)      // [func_sig(addWord), func_sig]
    eq                       // [func_sig(addWord) == func_sig]
    add_word jumpi           // []

    // Revert if no function signature matched
    0x00 0x00 revert

    // Create a jump label
    add_word:
        // Call the `ADD_WORD` macro with the first calldata
        // input, store the result in memory, and return it.
        0x04 calldataload    // [input_num]
        ADD_WORD()           // [result]
        0x00 mstore          // []
        0x20 0x00 return
}
</code></pre></div><h3 id="functions"><a href="#functions" class="header-anchor">#</a> Functions</h3> <p>Functions look extremely similar to macros, but behave somewhat differently.
Instead of the code being inserted at each invocation, the compiler moves
the code to the end of the runtime bytecode, and a jump to and from that
code is inserted at the points of invocation instead. This can be a useful
abstraction when a certain set of operations is used repeatedly throughout
your contract, and it is essentially a trade-off of decreasing contract size
for a small extra runtime gas cost (<code>22 + n_inputs * 3 + n_outputs * 3</code> gas
per invocation, to be exact).</p> <p>Functions are one of the only high-level abstractions
in Huff, so it is important to understand what the compiler adds to your code
when they are utilized. It is not always beneficial to re-use code, especially
if it is a small / inexpensive set of operations. However, for larger contracts
where certain logic is commonly reused, functions can help reduce the size of
the contract's bytecode to below the Spurious Dragon limit.</p> <h4 id="function-arguments"><a href="#function-arguments" class="header-anchor">#</a> Function Arguments</h4> <p>Functions can accept arguments to be &quot;called&quot; inside the macro or passed as a reference. Function arguments may be one of: label, opcode, literal, or a constant. Since functions are added to the end of the bytecode at compile-time, the arguments are not evaluated at runtime and are instead inlined as well.</p> <h4 id="example-6"><a href="#example-6" class="header-anchor">#</a> Example</h4> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>#define macro MUL_DIV_DOWN_WRAPPER() = takes (0) returns (0) {
    0x44 calldataload // [denominator]
    0x24 calldataload // [y, denominator]
    0x04 calldataload // [x, y, denominator]
    
    // Instead of the function's code being pasted at this invocation, it is put
    // at the end of the contract's runtime bytecode and a jump to the function's
    // code as well as a jumpdest to return to is inserted here. 
    //
    // The compiler looks at the amount of stack inputs the function takes (N) and
    // holds on to an array of N SWAP opcodes in descending order from 
    // SWAP1 (0x90) + N - 1 -&gt; SWAP1 (0x90)
    //
    // For this function invocation, we would need three swaps starting from swap3
    // and going to swap1. The return jumpdest PC must be below the function's
    // stack inputs, and the inputs still have to be in order.
    // 
    // [return_pc, x, y, denominator] (Starting stack state)
    // [denominator, x, y, return_pc] - swap3
    // [y, x, denominator, return_pc] - swap2
    // [x, y, denominator, return_pc] - swap1
    //
    // After this, the compiler inserts a jump to the jumpdest inserted at the
    // start of the function's code as well as a jumpdest to return to after
    // the function is finished executing.
    //
    // Code inserted when a function is invoked:
    // PUSH2 return_pc
    // &lt;num_inputs swap ops&gt;
    // PUSH2 func_start_pc
    // JUMP
    // JUMPDEST &lt;- this is the return_pc
    MUL_DIV_DOWN(err) // [result]

    // Return result
    0x00 mstore
    0x20 0x00 return

    err:
        0x00 0x00 revert
}

#define fn MUL_DIV_DOWN(err) = takes (3) returns (1) {
    // A jumpdest opcode is inserted here by the compiler
    // Starting stack: [x, y, denominator, return_pc]

    // function code ...

    // Because the compiler knows how many stack items the function returns (N),
    // it inserts N stack swaps in ascending order from
    // SWAP1 (0x90) -&gt; SWAP1 (0x90) + N - 1 in order to move the return_pc
    // back to the top of the stack so that it can be consumed by a JUMP
    //
    // [result, return_pc] (Starting stack state)
    // [return_pc, result] - swap1
    //
    // Final function code:
    // 👇 func_start_pc
    // JUMPDEST           [x, y, denominator, return_pc]
    // function code ...  [result, return_pc]
    // SWAP1              [return_pc, result]
    // JUMP               [result]
}
</code></pre></div><h2 id="builtin-functions"><a href="#builtin-functions" class="header-anchor">#</a> Builtin Functions</h2> <p>Several builtin functions are provided by the Huff compiler:</p> <h4 id="func-sig-func-def-string"><a href="#func-sig-func-def-string" class="header-anchor">#</a> <code>__FUNC_SIG(&lt;func_def|string&gt;)</code></h4> <p>At compile time, the invocation of <code>__FUNC_SIG</code> is substituted with <code>PUSH4 function_selector</code>, where <code>function_selector</code> is the 4 byte function selector of the passed function definition or string. If a string is passed, it must represent a valid function signature i.e. <code>&quot;test(address, uint256)&quot;</code></p> <h4 id="event-hash-event-def-string"><a href="#event-hash-event-def-string" class="header-anchor">#</a> <code>__EVENT_HASH(&lt;event_def|string&gt;)</code></h4> <p>At compile time, the invocation of <code>__EVENT_HASH</code> is substituted with <code>PUSH32 event_hash</code>, where <code>event_hash</code> is the selector hash of the passed event definition or string. If a string is passed, it must represent a valid event signature i.e. <code>&quot;TestEvent(uint256, address indexed)&quot;</code></p> <h4 id="error-error-def"><a href="#error-error-def" class="header-anchor">#</a> <code>__ERROR(&lt;error_def&gt;)</code></h4> <p>At compile time, the invocation of <code>__ERROR</code> is substituted with <code>PUSH32 error_selector</code>, where <code>error_selector</code> is the left-padded 4 byte error selector of the passed error definition.</p> <h4 id="rightpad-literal"><a href="#rightpad-literal" class="header-anchor">#</a> <code>__RIGHTPAD(&lt;literal&gt;)</code></h4> <p>At compile time, the invocation of <code>__RIGHTPAD</code> is substituted with <code>PUSH32 padded_literal</code>, where <code>padded_literal</code> is the right padded version of the passed literal.</p> <h4 id="codesize-macro-function"><a href="#codesize-macro-function" class="header-anchor">#</a> <code>__codesize(MACRO|FUNCTION)</code></h4> <p>Pushes the code size of the macro or function passed to the stack.</p> <h4 id="tablestart-table-and-tablesize-table"><a href="#tablestart-table-and-tablesize-table" class="header-anchor">#</a> <code>__tablestart(TABLE)</code> and <code>__tablesize(TABLE)</code></h4> <p>These functions related to Jump Tables are described in the next section.</p> <h4 id="example-7"><a href="#example-7" class="header-anchor">#</a> Example</h4> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>// Define a function
#define function test1(address, uint256) nonpayable returns (bool)
#define function test2(address, uint256) nonpayable returns (bool)

// Define an event
#define event TestEvent1(address, uint256)
#define event TestEvent2(address, uint256)

#define macro TEST1() = takes (0) returns (0) {
    0x00 0x00                // [address, uint]
    __EVENT_HASH(TestEvent1) // [sig, address, uint]
    0x00 0x00                // [mem_start, mem_end, sig, address, uint]
    log3                     // []
}

#define macro TEST2() = takes (0) returns (0) {
    0x00 0x00                // [address, uint]
    __EVENT_HASH(TestEvent2) // [sig, address, uint]
    0x00 0x00                // [mem_start, mem_end, sig, address, uint]
    log3                     // []
}

#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called.
    0x00 calldataload 0xE0 shr
    dup1 __FUNC_SIG(test1) eq test1 jumpi
    dup1 __FUNC_SIG(test2) eq test2 jumpi

    // Revert if no function matches
    0x00 0x00 revert

    test1:
        TEST1()

    test2:
        TEST2()
}
</code></pre></div><h2 id="jump-tables"><a href="#jump-tables" class="header-anchor">#</a> Jump Tables</h2> <p>Jump Tables are a convenient way to create switch cases in your
Huff contracts. Each jump table consists of jumpdest program counters (PCs), and it is
written to your contract's bytecode. These jumpdest PCs can be codecopied
into memory, and the case can be chosen by finding a jumpdest at a particular
memory pointer (i.e. 0x00 = case 1, 0x20 = case 2, etc.). This allows for a
single jump rather than many conditional jumps.</p> <p>There are two different kinds of Jump Tables in Huff: <code>Regular</code> and
<code>Packed</code>. Regular Jump Tables store jumpdest PCs as full 32 byte
words, and packed Jump Tables store them each as 2 bytes. Therefore,
packed jumptables are cheaper to copy into memory, but they are more
expensive to pull a PC out of due to the bitshifting required. The
opposite is true for Regular Jump Tables.</p> <p>There are two builtin functions related to jumptables.</p> <h4 id="tablestart-table"><a href="#tablestart-table" class="header-anchor">#</a> <code>__tablestart(TABLE)</code></h4> <p>Pushes the program counter (PC) of the start of the table passed to the stack.</p> <h4 id="tablesize-table"><a href="#tablesize-table" class="header-anchor">#</a> <code>__tablesize(TABLE)</code></h4> <p>Pushes the code size of the table passed to the stack.</p> <h4 id="example-8"><a href="#example-8" class="header-anchor">#</a> Example</h4> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>// Define a function
#define function switchTest(uint256) pure returns (uint256)

// Define a jump table containing 4 pcs
#define jumptable SWITCH_TABLE {
    jump_one jump_two jump_three jump_four
}

#define macro SWITCH_TEST() = takes (0) returns (0) {
    // Codecopy jump table into memory @ 0x00
    __tablesize(SWITCH_TABLE)   // [table_size]
    __tablestart(SWITCH_TABLE)  // [table_start, table_size]
    0x00
    codecopy

    0x04 calldataload           // [input_num]

    // Revert if input_num is not in the bounds of [0, 3]
    dup1                        // [input_num, input_num]
    0x03 lt                     // [3 &lt; input_num, input_num]
    err jumpi                       

    // Regular jumptables store the jumpdest PCs as full words,
    // so we simply multiply the input number by 32 to determine
    // which label to jump to.
    0x20 mul                    // [0x20 * input_num]
    mload                       // [pc]
    jump                        // []

    jump_one:
        0x100 0x00 mstore
        0x20 0x00 return
    jump_two:
        0x200 0x00 mstore
        0x20 0x00 return
    jump_three:
        0x300 0x00 mstore
        0x20 0x00 return
    jump_four:
        0x400 0x00 mstore
        0x20 0x00 return
    err:
        0x00 0x00 revert
}

#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called.
    0x00 calldataload 0xE0 shr
    dup1 __FUNC_SIG(switchTest) eq switch_test jumpi

    // Revert if no function matches
    0x00 0x00 revert

    switch_test:
        SWITCH_TEST()
}
</code></pre></div><h2 id="code-tables"><a href="#code-tables" class="header-anchor">#</a> Code Tables</h2> <p>Code Tables contain raw bytecode. The compiler places the code within
them at the end of the runtime bytecode, assuming they are referenced
somewhere within the contract.</p> <h4 id="example-9"><a href="#example-9" class="header-anchor">#</a> Example</h4> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>#define table CODE_TABLE {
    0x604260005260206000F3
}
</code></pre></div><h2 id="huff-tests"><a href="#huff-tests" class="header-anchor">#</a> Huff Tests</h2> <p>The compiler includes a simple, stripped-down testing framework to assist in creating assertions
as well as gas profiling macros and functions. huff-rs’ test suite is intentionally lacking in features,
and with that, this addition is not meant to replace developers’ dependency on <code>foundry-huff</code>. Ideally,
for contracts that will be in production, Huff developers will utilize both foundry and Huff tests.
If you are one of many who uses Huff as a tool for learning, Huff tests can also be a lighter weight
experience when testing your contract’s logic.</p> <p>Tests can be ran via the CLI's <code>test</code> subcommand. For more information, see the <a href="/resources/cli/">CLI Resources</a>.</p> <h3 id="decorators"><a href="#decorators" class="header-anchor">#</a> Decorators</h3> <p>The transaction environment for each test can be modified with a decorator. Decorators sit directly above
tests, and are formatted as follows: <code>#[flag_a(inputs...), flag_b(inputs...)]</code></p> <p>Available decorators include:</p> <ul><li><code>calldata</code> - Set the calldata for the transaction environment. Accepts a single string of calldata bytes.</li> <li><code>value</code> - Set the callvalue for the transaction environment. Accepts a single literal.</li></ul> <h4 id="example-10"><a href="#example-10" class="header-anchor">#</a> Example</h4> <div class="language-plaintext extra-class"><pre class="language-plaintext"><code>#include &quot;huffmate/utils/Errors.huff&quot;

#define macro ADD_TWO() = takes (2) returns (1) {
    // Input Stack:  [a, b]
    add           // [a + b]
    // Return Stack: [a + b]
}

#[calldata(&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;), value(0x01)]
#define test MY_TEST() = {
    0x00 calldataload   // [0x01]
    callvalue           // [0x01, 0x01]
    eq ASSERT()
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/get-started/project-quickstart/" class="prev">
        Huff Project Template
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f80e70d4.js" defer></script><script src="/assets/js/2.fbc25f86.js" defer></script><script src="/assets/js/12.ff418896.js" defer></script>
  </body>
</html>
