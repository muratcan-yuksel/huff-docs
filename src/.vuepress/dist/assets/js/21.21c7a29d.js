(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{449:function(e,n,t){"use strict";t.r(n);var a=t(66),i=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"function-dispatching"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#function-dispatching"}},[e._v("#")]),e._v(" Function Dispatching")]),e._v(" "),t("p",[e._v("Function dispatching is something that is fundamental to any Huff contract. Unlike Solidity and Vyper; Huff does not abstract function dispatching. In this section we will go over how dispatching is performed in the other languages, and how you may go about it in Huff.")]),e._v(" "),t("h2",{attrs:{id:"what-is-the-problem"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#what-is-the-problem"}},[e._v("#")]),e._v(" What is the problem?")]),e._v(" "),t("p",[e._v("In the evm, contracts are interacted with by sending messages to them. The ABI standard exists as a canonical way to encode these messages, handling how inputs to functions should be encoded. These strict rules are what allow contracts to understand each other. The ABI standard also tells the contract which function the message intends to interact with. This is done by encoding a 4 byte selector at the beginning of the message. This 4 byte selector is the first 4 bytes of the "),t("code",[e._v("keccak")]),e._v(' of the function\'s signature string. For example, the keccak256 hash of the string "myFunction(address,uint256)" is '),t("code",[e._v("0x451c00ddd225deee9948ba5eca26042a5ea1cc0980e5a5fb0a057f90567af5e0")]),e._v(". So the first 4 bytes "),t("code",[e._v("0x451c00dd")]),e._v(" is what Solidity uses as the function signature. If you have written interfaces in solidity you may not realize that you are just providing your current contract the ability to generate the 4 byte selectors of a foreign contract.")]),e._v(" "),t("p",[e._v("The rest of this section will detail two types of dispatching, linear dispatching and binary search dispatching.")]),e._v(" "),t("h2",{attrs:{id:"linear-dispatching"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linear-dispatching"}},[e._v("#")]),e._v(" Linear Dispatching")]),e._v(" "),t("p",[e._v("From reading the above, or from reading a Huff contract before you may have developed some intuition about how the simplest way to perform dispatching is - A linear lookup. This method will extract the function selector from the calldata message, then brute force compare it to every other function in the contract.")]),e._v(" "),t("p",[e._v("The example below shows what a linear dispatcher may look like for a standard ERC20 token:")]),e._v(" "),t("div",{staticClass:"language-huff extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n// Interface\n#define function allowance(address,address) view returns (uint256)\n#define function approve(address,uint256) nonpayable returns ()\n#define function balanceOf(address) view returns (uint256)\n#define function DOMAIN_SEPARATOR() view returns (bytes32)\n#define function nonces(address) view returns (uint256)\n#define function permit(address,address,uint256,uint256,uint8,bytes32,bytes32) nonpayable returns ()\n#define function totalSupply() view returns (uint256)\n#define function transfer(address,uint256) nonpayable returns ()\n#define function transferFrom(address,address,uint256) nonpayable returns ()\n#define function decimals() nonpayable returns (uint256)\n#define function name() nonpayable returns (string)\n#define function symbol() nonpayable returns (string)\n\n// Function Dispatching\n#define macro MAIN() = takes (1) returns (1) {\n    // Identify which function is being called.\n    0x00 calldataload 0xE0 shr          // [func_sig]\n\n    dup1 __FUNC_SIG(permit)             eq permitJump           jumpi\n    dup1 __FUNC_SIG(nonces)             eq noncesJump           jumpi\n\n    dup1 __FUNC_SIG(name)               eq nameJump             jumpi\n    dup1 __FUNC_SIG(symbol)             eq symbolJump           jumpi\n    dup1 __FUNC_SIG(decimals)           eq decimalsJump         jumpi\n    dup1 __FUNC_SIG(DOMAIN_SEPARATOR)   eq domainSeparatorJump  jumpi\n\n    dup1 __FUNC_SIG(totalSupply)        eq totalSupplyJump      jumpi\n    dup1 __FUNC_SIG(balanceOf)          eq balanceOfJump        jumpi\n    dup1 __FUNC_SIG(allowance)          eq allowanceJump        jumpi\n\n    dup1 __FUNC_SIG(transfer)           eq transferJump         jumpi\n    dup1 __FUNC_SIG(transferFrom)       eq transferFromJump     jumpi\n    dup1 __FUNC_SIG(approve)            eq approveJump          jumpi\n\n    // Revert if no match is found.\n    0x00 dup1 revert\n\n    allowanceJump:\n        ALLOWANCE()\n    approveJump:\n        APPROVE()\n    balanceOfJump:\n        BALANCE_OF()\n    decimalsJump:\n        DECIMALS()\n    domainSeparatorJump:\n        DOMAIN_SEPARATOR()\n    nameJump:\n        NAME()\n    noncesJump:\n        NONCES()\n    permitJump:\n        PERMIT()\n    symbolJump:\n        SYMBOL()\n    totalSupplyJump:\n        TOTAL_SUPPLY()\n    transferFromJump:\n        TRANSFER_FROM()\n    transferJump:\n        TRANSFER()\n}\n")])])]),t("p",[e._v("There is one extremely important piece of code you will use in almost all of your Huff contracts:")]),e._v(" "),t("div",{staticClass:"language-huff extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("0x00 calldataload 0xE0 shr\n")])])]),t("p",[e._v("This loads the four byte function selector onto the stack. "),t("code",[e._v("0x00 calldataload")]),e._v(" will load 32 bytes starting from position 0 onto the stack (if the calldata is less than 32 bytes then it will be right padded with zeros). "),t("code",[e._v("0xE0 shr")]),e._v(" right shifts the calldata by 224 bits, leaving 32 bits or 4 bytes remaining on the stack.")]),e._v(" "),t("p",[e._v("Despite this seeming like a rather naive approach, for most contracts it is often the most effective. As this is one large "),t("code",[e._v("if")]),e._v(" "),t("code",[e._v("else if")]),e._v(' chain, you can optimize by placing "hot functions" towards the top of your chain. Functions towards the front will cost less gas to invoke, but be aware as your function approaches the end of the chain it can really get expensive!')]),e._v(" "),t("p",[e._v("This method seems naive, however this is exactly how Vyper and Solidity* implement linear dispatching. If you want it to be cheaper to call, just move it higher up in the contract!")]),e._v(" "),t("p",[e._v("* Solidity implements this method when there are fewer than 5 functions, or the number of optimizer runs is small. Otherwise, it will use binary search dispatching.")]),e._v(" "),t("p",[e._v("You may be wondering what the series of jump labels followed by implementation macros mean. A good mental model is that the entire of your contract exists within your MAIN macro. If a macro is not referred to within main or nested within a macro that is invoked within MAIN then it will not be included in your contract. In reality the above contract when compiled looks like this:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("0x[dispatcher]<allowanceJumpLabel>[ALLOWANCE MACRO]<approveJumpLabel>[APPROVE MACRO]<balanceOfJump>[BALANCE_OF MACRO] ... <transferFromLabel>[TRANSFER_FROM MACRO]<transferJump>[TRANSFER MACRO]\n")])])]),t("p",[e._v("In Huff all of your macros are inlined into one long bytecode string (this is also true for Vyper and Solidity!). Due to this property it is salient that you terminate ALL of your top-level macros with some form of escape opcode ("),t("code",[e._v("return")]),e._v(", "),t("code",[e._v("stop")]),e._v(", "),t("code",[e._v("revert")]),e._v("). If you don't do this your macro "),t("em",[e._v("WILL")]),e._v(" continue to execute which ever macro is inlined next until a return condition is found.")]),e._v(" "),t("p",[e._v("For example:")]),e._v(" "),t("div",{staticClass:"language-huff extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#define function returnOne() public returns(uint256)\n#define function returnTwo() public returns(uint256)\n\n/// @notice returns the value one\n#define macro RETURN_ONE() = {\n    0x01 0x00 mstore\n    0x20 0x00 return\n}\n\n/// @notice places the value 2 onto the stack\n#define macro RETURN_TWO() = {\n    0x02\n}\n\n#define macro MAIN() = {\n    0x00 calldataload 0xE0 shr\n\n    // Dispatcher\n    dup1 __FUNC_SIG(returnOne) eq returnOneJump jumpi\n    dup1 __FUNC_SIG(returnTwo) eq returnTwoJump jumpi\n\n    // Macros\n    returnTwo:\n        RETURN_TWO()\n    returnOne:\n        RETURN_ONE()\n}\n")])])]),t("p",[e._v("In the above macro, regardless if what message is sent to it, it will ALWAYS return the value 1. As the macro "),t("code",[e._v("RETURN_TWO")]),e._v(" does not terminate, it will roll over into the execution of "),t("code",[e._v("RETURN_ONE")]),e._v(", terminating with returning the value one. As there is no guard to protect against non valid function signatures any message, even if it matches nothing in the dispatcher will return the value 1.")]),e._v(" "),t("p",[e._v("One way we can handle no valid function selector being found is by inserting "),t("code",[e._v("0x00 0x00 revert")]),e._v(" in-between our dispatcher and our macro jump labels as so:")]),e._v(" "),t("div",{staticClass:"language-huff extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#define macro MAIN() = {\n    0x00 calldataload 0xE0 shr\n\n    dup1 __FUNC_SIG(returnOne) eq returnOneJump jumpi\n    dup1 __FUNC_SIG(returnTwo) eq returnTwoJump jumpi\n\n    0x00 0x00 revert\n\n    returnTwo:\n        RETURN_TWO()\n    returnOne:\n        RETURN_ONE()\n}\n")])])]),t("p",[e._v("Please keep this behavior in mind when writing Huff contracts, especially when dealing with administration functions, running into a "),t("code",[e._v("SET_OWNER()")]),e._v(' macro could allow anyone to take control of your contract. There is a more advanced way of jumping over the macro calling logic that is used with Huff "inheritance" pattern that we will discuss in another section.')]),e._v(" "),t("h2",{attrs:{id:"binary-search-dispatching"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#binary-search-dispatching"}},[e._v("#")]),e._v(" Binary Search Dispatching")]),e._v(" "),t("p",[e._v("Another method of function dispatching is by doing a binary search to find the correct selector. This is great for contracts with lots and lots of functions as it makes the dispatching cost more predictable / steady (No more checking every single branch of the "),t("code",[e._v("if else")]),e._v(" chain). In this method, we order our function selectors by their keccak, then pivot about a number of jump points until we reach the desired function. The number of jump points you include is up to you. The more jumps you add the more consistent your jump price will be, however, be mindful of the gas cost for comparisons. Generally, each split will add 16-18 bytes of additional code (remember there is a jump out of each pivot point).")]),e._v(" "),t("p",[e._v("To implement this approach you will need to manually calculate the function selectors and order them by hand. But do not worry, this can be done easily with a script.")]),e._v(" "),t("p",[e._v("Here is an example implementation of a binary search dispatch.")]),e._v(" "),t("div",{staticClass:"language-huff extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n// Define Interface\n#define function allowance(address,address) view returns (uint256)\n#define function approve(address,uint256) nonpayable returns ()\n#define function balanceOf(address) view returns (uint256)\n#define function DOMAIN_SEPARATOR() view returns (bytes32)\n#define function nonces(address) view returns (uint256)\n#define function permit(address,address,uint256,uint256,uint8,bytes32,bytes32) nonpayable returns ()\n#define function totalSupply() view returns (uint256)\n#define function transfer(address,uint256) nonpayable returns ()\n#define function transferFrom(address,address,uint256) nonpayable returns ()\n#define function decimals() nonpayable returns (uint256)\n#define function name() nonpayable returns (string)\n#define function symbol() nonpayable returns (string)\n\n// Function Dispatching\n#define macro MAIN() = takes (1) returns (1) {\n    // Identify which function is being called.\n    // [func sig]\n    0x00 calldataload 0xE0 shr\n\n    // The function selector of the pivot (number of selectors / 2)\n    dup1 __FUNC_SIG(balanceOf) lt pivot0 jumpi\n\n        // pivot 2\n        dup1 __FUNC_SIG(totalSupply) lt pivot00 jumpi\n\n            // 1\n            dup1 __FUNC_SIG(name)               eq nameJump             jumpi\n\n            // 2\n            dup1 __FUNC_SIG(approve)            eq approveJump          jumpi\n\n            // 3\n            dup1 __FUNC_SIG(totalSupply)        eq totalSupplyJump      jumpi\n\n            not_found jump\n\n        pivot00:\n\n            // 4\n            dup1 __FUNC_SIG(transferFrom)       eq transferFromJump     jumpi\n\n            // 5\n            dup1 __FUNC_SIG(decimals)           eq decimalsJump         jumpi\n\n            // 6\n            dup1 __FUNC_SIG(DOMAIN_SEPARATOR)   eq domainSeparatorJump  jumpi\n\n            not_found jump\n\n    pivot0:\n\n        dup1 __FUNC_SIG(symbol) lt pivot11 jumpi\n\n\n            // 7\n            dup1 __FUNC_SIG(balanceOf)          eq balanceOfJump        jumpi\n\n            // 8\n            dup1 __FUNC_SIG(nonces)             eq noncesJump           jumpi\n\n            // 9\n            dup1 __FUNC_SIG(symbol)             eq symbolJump           jumpi\n\n            not_found jump\n\n        pivot11:\n\n            // 10\n            dup1 __FUNC_SIG(transfer)           eq transferJump         jumpi\n\n            // 11\n            dup1  __FUNC_SIG(permit)             eq permitJump           jumpi\n\n            // 12\n            dup1 __FUNC_SIG(allowance)          eq allowanceJump        jumpi\n\n    not_found:\n\n    // Revert if no match is found.\n    0x00 dup1 revert\n\n    allowanceJump:\n        ALLOWANCE()\n    approveJump:\n        APPROVE()\n    balanceOfJump:\n        BALANCE_OF()\n    decimalsJump:\n        DECIMALS()\n    domainSeparatorJump:\n        DOMAIN_SEPARATOR()\n    nameJump:\n        NAME()\n    noncesJump:\n        NONCES()\n    permitJump:\n        PERMIT()\n    symbolJump:\n        SYMBOL()\n    totalSupplyJump:\n        TOTAL_SUPPLY()\n    transferFromJump:\n        TRANSFER_FROM()\n    transferJump:\n        TRANSFER()\n}\n")])])]),t("h2",{attrs:{id:"fallback-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fallback-functions"}},[e._v("#")]),e._v(" Fallback functions")]),e._v(" "),t("p",[e._v("In solidity there are two special functions, fallback and receive. Both are relatively straightforward to implement in Huff.")]),e._v(" "),t("p",[e._v("To implement fallback, just place a macro at the end of your dispatch logic, take for example the following fallback function that will always return the value 1:")]),e._v(" "),t("div",{staticClass:"language-huff extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#define macro FALLBACK() = {\n    0x01 0x00 mstore\n    0x20 0x00 return\n}\n")])])]),t("p",[e._v("Implementing it as a fallback is as simple as throwing it after you have exhausted your switch cases.")]),e._v(" "),t("div",{staticClass:"language-huff extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#define macro MAIN() = takes (1) returns (1) {\n    // Identify which function is being called.\n    // [func sig]\n    0x00 calldataload 0xE0 shr\n\n    dup1 __FUNC_SIG(permit)             eq permitJump           jumpi\n\n    ...\n\n    dup1 __FUNC_SIG(approve)            eq approveJump          jumpi\n\n    FALLBACK()\n\n   permitJump:\n        PERMIT()\n\n    ...\n\n    approveJump:\n        APPROVE()\n}\n")])])]),t("p",[e._v("If you want to implement both fallback and receive macros you can do the following:")]),e._v(" "),t("div",{staticClass:"language-huff extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#define macro MAIN() = takes (1) returns (1) {\n    // Identify which function is being called.\n    // [func sig]\n    0x00 calldataload 0xE0 shr\n\n    dup1 __FUNC_SIG(permit)             eq permitJump           jumpi\n\n    ...\n\n    dup1 __FUNC_SIG(approve)            eq approveJump          jumpi\n\n    # Jump into the receive function if msg.value is not zero\n    callvalue receive jumpi\n\n    FALLBACK()\n\n    receive:\n        RECEIVE()\n\n    permitJump:\n        PERMIT()\n\n    ...\n\n    approveJump:\n        APPROVE()\n}\n")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);