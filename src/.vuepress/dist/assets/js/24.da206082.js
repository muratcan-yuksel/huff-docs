(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{453:function(e,t,a){"use strict";a.r(t);var n=a(66),r=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"simple-storage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-storage"}},[e._v("#")]),e._v(" Simple Storage")]),e._v(" "),a("p",[e._v("So far the two examples we have looked at have explored slicing bytes from calldata, storing in memory and returning values. Now we're going to address the missing piece of the puzzle that all EVM devs fear, storage.")]),e._v(" "),a("h2",{attrs:{id:"storage-in-huff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#storage-in-huff"}},[e._v("#")]),e._v(" Storage in Huff")]),e._v(" "),a("p",[e._v("Thankfully working with storage isn't too complicated, Huff abstracts keeping track of storage variables through the "),a("code",[e._v("FREE_STORAGE_POINTER()")]),e._v(" keyword. An example of which will be shown below:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#define constant STORAGE_SLOT0 = FREE_STORAGE_POINTER()\n#define constant STORAGE_SLOT1 = FREE_STORAGE_POINTER()\n#define constant STORAGE_SLOT2 = FREE_STORAGE_POINTER()\n")])])]),a("p",[e._v("Storage slots are simply keys in a very large array where contracts keep their state. The compiler will assign "),a("code",[e._v("STORAGE_SLOT0")]),e._v(" the value "),a("code",[e._v("0")]),e._v(", "),a("code",[e._v("STORAGE_SLOT1")]),e._v(" the value "),a("code",[e._v("1")]),e._v(" etc. at compile time. Throughout your code you just reference the storage slots the same way constants are used in any language.")]),e._v(" "),a("h2",{attrs:{id:"setting-storage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setting-storage"}},[e._v("#")]),e._v(" Setting storage")]),e._v(" "),a("p",[e._v("First define the constant that will represent your storage slot using the "),a("code",[e._v("FREE_STORAGE_POINTER()")]),e._v(" keyword.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#define constant VALUE = FREE_STORAGE_POINTER()\n")])])]),a("p",[e._v("We can then reference this slot throughout the code by wrapping it in square brackets - like so "),a("code",[e._v("[VALUE]")]),e._v(". The example below demonstrates a macro that will store the value 5 in the slot [VALUE].")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#define macro SET_5() = takes(0) returns(0) {\n    0x5             // [0x5] \n    [VALUE]         // [value_slot_pointer, 0x5]\n    sstore          // []\n}\n")])])]),a("p",[e._v("Test this out interactively "),a("a",{attrs:{href:"https://www.evm.codes/playground?unit=Wei&codeType=Bytecode&code='6005600055'_",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1),e._v(" ([VALUE] has been hardcoded to 0)")]),e._v(" "),a("h2",{attrs:{id:"reading-from-storage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reading-from-storage"}},[e._v("#")]),e._v(" Reading from storage")]),e._v(" "),a("p",[e._v("Now you know how to write to storage, reading from storage is trivial. Simply replace "),a("code",[e._v("sstore")]),e._v(" with "),a("code",[e._v("sload")]),e._v(" and your ready to go. We are going to extend our example above to both write and read from storage.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#define macro SET_5_READ_5() = takes(0) returns(0) {\n    0x5\n    [VALUE]\n    sstore\n\n    [VALUE]\n    sload\n}\n")])])]),a("p",[e._v("Nice! Once again you can test this out over at "),a("a",{attrs:{href:"https://www.evm.codes/playground?unit=Wei&codeType=Bytecode&code='6005600055600054'_",target:"_blank",rel:"noopener noreferrer"}},[e._v("evm.codes"),a("OutboundLink")],1),e._v(". Notice how 5 reappears on the stack after executing the "),a("code",[e._v("sload")]),e._v(" instruction.")]),e._v(" "),a("h2",{attrs:{id:"simple-storage-implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-storage-implementation"}},[e._v("#")]),e._v(" Simple Storage Implementation")]),e._v(" "),a("p",[e._v("Now we can read and write to storage, lets attempt the famous SimpleStorage starter contract from remix.")]),e._v(" "),a("p",[e._v("First off, lets create our interface:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#define function setValue(uint256) nonpayable returns ()\n#define function getValue() nonpayable returns (uint256)\n")])])]),a("p",[e._v("Now lets define our storage slots:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#define constant VALUE = FREE_STORAGE_POINTER()\n")])])]),a("p",[e._v("Onto the fun part, the logic. Remember from the addTwo example we can read calldata in 32 byte chunks using the "),a("code",[e._v("calldataload")]),e._v(" opcode, lets use that knowledge to get read our uint256.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#define macro SET_VALUE() = takes(0) returns(0) {\n    // Read uint256 from calldata, remember to read from byte 4 to allow for the function selector! \n    0x04            // [0x04]\n    calldataload    // [value]\n\n    // Get pointer and store\n    [VALUE]         // [value_ptr, value]\n    sstore          // []\n}\n")])])]),a("p",[e._v("After completing the previous examples we hope that writing Huff is all starting to click! This pattern will be extremely common when writing your own contracts, reading from calldata then storing values in memory or storage.")]),e._v(" "),a("p",[e._v("Next up is reading the stored value.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#define macro GET_VALUE() = takes(0) returns(0) {\n    // Read uint256 from storage\n    [VALUE]         // [value_ptr]\n    sload           // [value]\n\n    // Store the return value in memory\n    0x00            // [0x00, value]\n    mstore          // []\n\n    // Return the first 32 bytes of memory containing our uint256\n    0x20            // [0x20]\n    0x00            // [0x00, 0x20]\n    return          // []\n}\n")])])]),a("p",[e._v("First off, we read the storage value using a similar technique to our prior example. Prepare the return value by storing it in memory. Then return the value from memory. It's all coming together!")]),e._v(" "),a("p",[e._v("To call our new macros from external functions we have to create a dispatcher!")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#define macro MAIN() = takes(0) returns(0) {\n    \n    // Get the function selector\n    0x00 calldataload 0xe0 shr\n\n    dup1 __FUNC_SIG(setValue) eq setValue jumpi // Compare function selector to setValue(uint256)\n    dup1 __FUNC_SIG(getValue) eq getValue jumpi // Compare the function selector to getValue()\n\n    // dispatch\n    setValue:\n        SET_VALUE()\n    getValue:\n        GET_VALUE()\n\n    0x00 0x00 revert\n}\n")])])]),a("p",[e._v("Now all of it together!")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Interface\n#define function setValue(uint256) nonpayable returns ()\n#define function getValue() nonpayable returns (uint256)\n\n// Storage\n#define constant VALUE = FREE_STORAGE_POINTER()\n\n// External function macros\n\n// setValue(uint256)\n#define macro SET_VALUE() = takes(0) returns(0) {\n    // Read uint256 from calldata, remember to read from byte 4 to allow for the function selector! \n    0x04            // [0x04]\n    calldataload    // [value]\n\n    // Get pointer and store\n    [VALUE]         // [value_ptr, value]\n    sstore          // []\n}\n\n// getValue()\n#define macro GET_VALUE() = takes(0) returns(0) {\n    // Read uint256 from storage\n    [VALUE]         // [value_ptr]\n    sload           // [value]\n\n    // Store the return value in memory\n    0x00            // [0x00, value]\n    mstore          // []\n\n    // Return the first 32 bytes of memory containing our uint256\n    0x20            // [0x20]\n    0x00            // [0x00, 0x20]\n    return          // []\n}\n\n// Main\n#define macro MAIN() = takes(0) returns(0) {\n    // Get the function selector\n    0x00 calldataload 0xe0 shr\n\n    dup1 __FUNC_SIG(setValue) eq setValue jumpi // Compare function selector to setValue(uint256)\n    dup1 __FUNC_SIG(getValue) eq getValue jumpi // Compare the function selector to getValue()\n\n    // dispatch\n    setValue:\n        SET_VALUE()\n    getValue:\n        GET_VALUE()\n\n    0x00 0x00 revert\n}\n")])])]),a("p",[e._v('Congratulations! You\'ve made it through the crust of writing contracts in Huff. For your next steps we recommend taking what you have learned so far in addTwo, "Hello, World!" and SimpleStorage into a testing framework like '),a("a",{attrs:{href:"https://docs.huff.sh/tutorial/huff-testing/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Foundry"),a("OutboundLink")],1),e._v(". Happy hacking!")])])}),[],!1,null,null,null);t.default=r.exports}}]);