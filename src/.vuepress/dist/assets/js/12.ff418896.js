(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{441:function(e,t,n){"use strict";n.r(t);var a=n(66),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"huff-by-example"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#huff-by-example"}},[e._v("#")]),e._v(" Huff by Example")]),e._v(" "),n("h2",{attrs:{id:"introduction"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),n("p",[e._v("Huff by Example is an effort to provide a thorough explanation of each\nfeature of the Huff language, along with code-snippet examples detailing how,\nwhen, where, and why to use each one. The snippets here are heavily\ncommentated, but this section does assume some prior experience working\nwith the EVM.")]),e._v(" "),n("p",[e._v("If you are new to low-level EVM programming, please read the\n"),n("a",{attrs:{href:"/tutorial/overview"}},[e._v("Tutorials")]),e._v(" section of the docs before diving into\nHuff development. If you run into any issues, please feel free to come ask\nthe community questions on "),n("a",{attrs:{href:"https://discord.gg/C3gTvkFNRR",target:"_blank",rel:"noopener noreferrer"}},[e._v("Discord"),n("OutboundLink")],1),e._v("!")]),e._v(" "),n("h2",{attrs:{id:"defining-your-interface"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#defining-your-interface"}},[e._v("#")]),e._v(" Defining your Interface")]),e._v(" "),n("p",[e._v("While defining an interface is not a necessary step, "),n("code",[e._v("functions")]),e._v(" and "),n("code",[e._v("events")]),e._v("\ncan be defined in Huff contracts for two purposes: To be used as arguments\nfor the "),n("code",[e._v("__FUNC_SIG")]),e._v(" and "),n("code",[e._v("__EVENT_HASH")]),e._v(" builtins, and to generate a Solidity\nInterface / Contract ABI.")]),e._v(" "),n("p",[e._v("Functions can be of type "),n("code",[e._v("view")]),e._v(", "),n("code",[e._v("pure")]),e._v(", "),n("code",[e._v("payable")]),e._v(" or "),n("code",[e._v("nonpayable")]),e._v(", and\nfunction interfaces should only be defined for externally facing functions.")]),e._v(" "),n("p",[e._v("Events can contain "),n("code",[e._v("indexed")]),e._v(" and non-indexed values.")]),e._v(" "),n("h4",{attrs:{id:"example"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example"}},[e._v("#")]),e._v(" Example")]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v("#define function testFunction(uint256, bytes32) view returns (bytes memory)\n\n#define event TestEvent(address indexed, uint256)\n")])])]),n("h2",{attrs:{id:"constants"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#constants"}},[e._v("#")]),e._v(" Constants")]),e._v(" "),n("p",[e._v("Constants in Huff contracts are not included in the contract's storage; Instead,\nthey are able to be called within the contract at compile time. Constants\ncan either be bytes (32 max) or a "),n("code",[e._v("FREE_STORAGE_POINTER")]),e._v(". A "),n("code",[e._v("FREE_STORAGE_POINTER")]),e._v("\nconstant will always represent an unused storage slot in the contract.")]),e._v(" "),n("p",[e._v("In order to push a constant to the stack, use bracket notation: "),n("code",[e._v("[CONSTANT]")])]),e._v(" "),n("h4",{attrs:{id:"example-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-2"}},[e._v("#")]),e._v(" Example")]),e._v(" "),n("p",[n("strong",[e._v("Constant Declaration")])]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v("#define constant NUM = 0x420\n#define constant HELLO_WORLD = 0x48656c6c6f2c20576f726c6421\n#define constant FREE_STORAGE = FREE_STORAGE_POINTER()\n")])])]),n("p",[n("strong",[e._v("Constant Usage")]),e._v("\n(without loss of generality, let's say the constant "),n("code",[e._v("NUM")]),e._v(" holds 0x420 from the above example)")]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v("                    // [] - an empty stack\n[NUM]               // [0x420] - the constant's value is pushed to the stack\n")])])]),n("h2",{attrs:{id:"custom-errors"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#custom-errors"}},[e._v("#")]),e._v(" Custom Errors")]),e._v(" "),n("p",[e._v("Custom errors can be defined and used by the "),n("code",[e._v("__ERROR")]),e._v(" builtin to push the left-padded 4 byte\nerror selector to the stack.")]),e._v(" "),n("h4",{attrs:{id:"example-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-3"}},[e._v("#")]),e._v(" Example")]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v("// Define our custom error\n#define error PanicError(uint256)\n#define error Error(string)\n\n#define macro PANIC() = takes (1) returns (0) {\n    // Input stack:          [panic_code]\n    __ERROR(PanicError)   // [panic_error_selector, panic_code]\n    0x00 mstore           // [panic_code]\n    0x04 mstore           // []\n    0x24 0x00 revert\n}\n\n#define macro REQUIRE() = takes (3) returns (0) {\n    // Input stack:          [condition, message_length, message]\n    continue jumpi        // [message_length, message]\n\n    __ERROR(Error)        // [error_selector, message_length, message]\n    0x00 mstore           // [message_length, message]\n    0x20 0x04 mstore      // [message_length, message]\n    0x24 mstore           // [message]\n    0x44 mstore           // []\n\n    0x64 0x00 revert\n\n    continue:\n        pop               // []\n}\n")])])]),n("h2",{attrs:{id:"jump-labels"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jump-labels"}},[e._v("#")]),e._v(" Jump Labels")]),e._v(" "),n("p",[e._v("Jump Labels are a simple abstraction included into the language to make defining\nand referring to "),n("code",[e._v("JUMPDEST")]),e._v("s more simple for the developer.")]),e._v(" "),n("h4",{attrs:{id:"example-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-4"}},[e._v("#")]),e._v(" Example")]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v('#define macro MAIN() = takes (0) returns (0) {\n    // Store "Hello, World!" in memory\n    0x48656c6c6f2c20576f726c6421\n    0x00 mstore // ["Hello, World!"]\n\n    // Jump to success label, skipping the revert statement\n    success     // [success_label_pc, "Hello, World!"]\n    jump        // ["Hello, World!"]\n\n    // Revert if this point is reached\n    0x00 0x00 revert\n\n    // Labels are defined within macros or functions, and are designated\n    // by a word followed by a colon. Note that while it may appear as if\n    // labels are scoped code blocks due to the indentation, they are simply\n    // destinations to jump to in the bytecode. If operations exist below a label,\n    // they will be executed unless the program counter is altered or execution is\n    // halted by a `revert`, `return`, `stop`, or `selfdestruct` opcode.\n    success:\n        0x00 mstore\n        0x20 0x00 return\n}\n')])])]),n("h2",{attrs:{id:"macros-and-functions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#macros-and-functions"}},[e._v("#")]),e._v(" Macros and Functions")]),e._v(" "),n("p",[e._v("Huff offers two ways to group together your bytecode: Macros and Functions. It is\nimportant to understand the difference between the two, and when to use one\nover the other.")]),e._v(" "),n("p",[e._v("Both are defined similarly, taking optional arguments as well as being followed\nby the "),n("code",[e._v("takes")]),e._v(" and "),n("code",[e._v("returns")]),e._v(" keywords. These designate the amount of stack\ninputs the macro/function takes in as well as the amount of stack elements the\nmacro/function outputs. The "),n("code",[e._v("takes")]),e._v(" and "),n("code",[e._v("returns")]),e._v(" keywords are optional - if they are\nnot present, the value will default to "),n("code",[e._v("0")]),e._v(".")]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v("#define <macro|fn> TEST(err) = takes (1) returns (3) {\n    // ...\n}\n")])])]),n("h3",{attrs:{id:"macros"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#macros"}},[e._v("#")]),e._v(" Macros")]),e._v(" "),n("p",[e._v("Most of the time, Huff developers should opt to use macros. Each time a macro is invoked,\nthe code within it is placed at the point of invocation. This is efficient in\nterms of runtime gas cost due to not having to jump to and from the macro's code,\nbut it can quickly increase the size of the contract's bytecode if it is used commonly\nthroughout.")]),e._v(" "),n("h4",{attrs:{id:"constructor-and-main"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#constructor-and-main"}},[e._v("#")]),e._v(" Constructor and Main")]),e._v(" "),n("p",[n("code",[e._v("MAIN")]),e._v(" and "),n("code",[e._v("CONSTRUCTOR")]),e._v(" are two important macros that serve special purposes. When\nyour contract is called, the "),n("code",[e._v("MAIN")]),e._v(" macro will be the fallback, and it is commonly where\na Huff contract's control flow begins. The "),n("code",[e._v("CONSTRUCTOR")]),e._v(" macro, while not required,\ncan be used to initialize the contract upon deployment. Inputs to the "),n("code",[e._v("CONSTRUCTOR")]),e._v(" macro\nare provided at compile time.")]),e._v(" "),n("p",[e._v("By default, the "),n("code",[e._v("CONSTRUCTOR")]),e._v(" will add some bootstrap code that returns the compiled MAIN macro\nas the contract's runtime bytecode. If the constructor contains a "),n("code",[e._v("RETURN")]),e._v(" opcode, the compiler\nwill not include this bootstrap, and it will instead instantiate the contract with the code returned\nby the constructor.")]),e._v(" "),n("h4",{attrs:{id:"macro-arguments"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#macro-arguments"}},[e._v("#")]),e._v(" Macro Arguments")]),e._v(" "),n("p",[e._v('Macros can accept arguments to be "called" inside the macro or passed as a reference. Macro arguments may be one of: label, opcode, literal, or a constant. Since macros are inlined at compile-time, the arguments are not evaluated at runtime and are instead inlined as well.')]),e._v(" "),n("h4",{attrs:{id:"example-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-5"}},[e._v("#")]),e._v(" Example")]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v("// Define the contract's interface\n#define function addWord(uint256) pure returns (uint256)\n\n// Get a free storage slot to store the owner\n#define constant OWNER = FREE_STORAGE_POINTER()\n\n// Define the event we wish to emit\n#define event WordAdded(uint256 initial, uint256 increment)\n\n// Macro to emit an event that a word has been added\n#define macro emitWordAdded(increment) = takes (1) returns (0) {\n    // input stack: [initial]\n    <increment>              // [increment, initial]\n    __EVENT_HASH(WordAdded)  // [sig, increment, initial]\n    0x00 0x00                // [mem_start, mem_end, sig, increment, initial]\n    log3                     // []\n}\n\n// Only owner function modifier\n#define macro ONLY_OWNER() = takes (0) returns (0) {\n    caller                   // [msg.sender]\n    [OWNER] sload            // [owner, msg.sender]\n    eq                       // [owner == msg.sender]\n    is_owner jumpi           // []\n\n    // Revert if the sender is not the owner\n    0x00 0x00 revert\n\n    is_owner:\n}\n\n// Add a word (32 bytes) to a uint \n#define macro ADD_WORD() = takes (1) returns (1) {\n    // Input Stack:          // [input_num]\n\n    // Enforce that the caller is the owner. The code of the\n    // `ONLY_OWNER` macro will be pasted at this invocation. \n    ONLY_OWNER()\n\n    // Call our helper macro that emits an event when a word is added\n    // Here we pass a literal that represents how much we increment the word by.\n    // NOTE: We need to duplicate the input number on our stack since\n    //       emitWordAdded takes 1 stack item and returns 0\n    dup1                     // [input_num, input_num]\n    emitWordAdded(0x20)      // [input_num]\n\n    // NOTE: 0x20 is automatically pushed to the stack, it is assumed to be a \n    // literal by the compiler.\n    0x20                     // [0x20, input_num]\n    add                      // [0x20 + input_num]\n\n    // Return stack:            [0x20 + input_num]\n}\n\n#define macro MAIN() = takes (0) returns (0) {\n    // Get the function signature from the calldata\n    0x00 calldataload        // [calldata @ 0x00]\n    0xE0 shr                 // [func_sig (calldata @ 0x00 >> 0xE0)]\n\n    // Check if the function signature in the calldata is\n    // a match to our `addWord` function definition.\n    // More about the `__FUNC_SIG` builtin in the `Builtin Functions`\n    // section.\n    __FUNC_SIG(addWord)      // [func_sig(addWord), func_sig]\n    eq                       // [func_sig(addWord) == func_sig]\n    add_word jumpi           // []\n\n    // Revert if no function signature matched\n    0x00 0x00 revert\n\n    // Create a jump label\n    add_word:\n        // Call the `ADD_WORD` macro with the first calldata\n        // input, store the result in memory, and return it.\n        0x04 calldataload    // [input_num]\n        ADD_WORD()           // [result]\n        0x00 mstore          // []\n        0x20 0x00 return\n}\n")])])]),n("h3",{attrs:{id:"functions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#functions"}},[e._v("#")]),e._v(" Functions")]),e._v(" "),n("p",[e._v("Functions look extremely similar to macros, but behave somewhat differently.\nInstead of the code being inserted at each invocation, the compiler moves\nthe code to the end of the runtime bytecode, and a jump to and from that\ncode is inserted at the points of invocation instead. This can be a useful\nabstraction when a certain set of operations is used repeatedly throughout\nyour contract, and it is essentially a trade-off of decreasing contract size\nfor a small extra runtime gas cost ("),n("code",[e._v("22 + n_inputs * 3 + n_outputs * 3")]),e._v(" gas\nper invocation, to be exact).")]),e._v(" "),n("p",[e._v("Functions are one of the only high-level abstractions\nin Huff, so it is important to understand what the compiler adds to your code\nwhen they are utilized. It is not always beneficial to re-use code, especially\nif it is a small / inexpensive set of operations. However, for larger contracts\nwhere certain logic is commonly reused, functions can help reduce the size of\nthe contract's bytecode to below the Spurious Dragon limit.")]),e._v(" "),n("h4",{attrs:{id:"function-arguments"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function-arguments"}},[e._v("#")]),e._v(" Function Arguments")]),e._v(" "),n("p",[e._v('Functions can accept arguments to be "called" inside the macro or passed as a reference. Function arguments may be one of: label, opcode, literal, or a constant. Since functions are added to the end of the bytecode at compile-time, the arguments are not evaluated at runtime and are instead inlined as well.')]),e._v(" "),n("h4",{attrs:{id:"example-6"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-6"}},[e._v("#")]),e._v(" Example")]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v("#define macro MUL_DIV_DOWN_WRAPPER() = takes (0) returns (0) {\n    0x44 calldataload // [denominator]\n    0x24 calldataload // [y, denominator]\n    0x04 calldataload // [x, y, denominator]\n    \n    // Instead of the function's code being pasted at this invocation, it is put\n    // at the end of the contract's runtime bytecode and a jump to the function's\n    // code as well as a jumpdest to return to is inserted here. \n    //\n    // The compiler looks at the amount of stack inputs the function takes (N) and\n    // holds on to an array of N SWAP opcodes in descending order from \n    // SWAP1 (0x90) + N - 1 -> SWAP1 (0x90)\n    //\n    // For this function invocation, we would need three swaps starting from swap3\n    // and going to swap1. The return jumpdest PC must be below the function's\n    // stack inputs, and the inputs still have to be in order.\n    // \n    // [return_pc, x, y, denominator] (Starting stack state)\n    // [denominator, x, y, return_pc] - swap3\n    // [y, x, denominator, return_pc] - swap2\n    // [x, y, denominator, return_pc] - swap1\n    //\n    // After this, the compiler inserts a jump to the jumpdest inserted at the\n    // start of the function's code as well as a jumpdest to return to after\n    // the function is finished executing.\n    //\n    // Code inserted when a function is invoked:\n    // PUSH2 return_pc\n    // <num_inputs swap ops>\n    // PUSH2 func_start_pc\n    // JUMP\n    // JUMPDEST <- this is the return_pc\n    MUL_DIV_DOWN(err) // [result]\n\n    // Return result\n    0x00 mstore\n    0x20 0x00 return\n\n    err:\n        0x00 0x00 revert\n}\n\n#define fn MUL_DIV_DOWN(err) = takes (3) returns (1) {\n    // A jumpdest opcode is inserted here by the compiler\n    // Starting stack: [x, y, denominator, return_pc]\n\n    // function code ...\n\n    // Because the compiler knows how many stack items the function returns (N),\n    // it inserts N stack swaps in ascending order from\n    // SWAP1 (0x90) -> SWAP1 (0x90) + N - 1 in order to move the return_pc\n    // back to the top of the stack so that it can be consumed by a JUMP\n    //\n    // [result, return_pc] (Starting stack state)\n    // [return_pc, result] - swap1\n    //\n    // Final function code:\n    // 👇 func_start_pc\n    // JUMPDEST           [x, y, denominator, return_pc]\n    // function code ...  [result, return_pc]\n    // SWAP1              [return_pc, result]\n    // JUMP               [result]\n}\n")])])]),n("h2",{attrs:{id:"builtin-functions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#builtin-functions"}},[e._v("#")]),e._v(" Builtin Functions")]),e._v(" "),n("p",[e._v("Several builtin functions are provided by the Huff compiler:")]),e._v(" "),n("h4",{attrs:{id:"func-sig-func-def-string"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#func-sig-func-def-string"}},[e._v("#")]),e._v(" "),n("code",[e._v("__FUNC_SIG(<func_def|string>)")])]),e._v(" "),n("p",[e._v("At compile time, the invocation of "),n("code",[e._v("__FUNC_SIG")]),e._v(" is substituted with "),n("code",[e._v("PUSH4 function_selector")]),e._v(", where "),n("code",[e._v("function_selector")]),e._v(" is the 4 byte function selector of the passed function definition or string. If a string is passed, it must represent a valid function signature i.e. "),n("code",[e._v('"test(address, uint256)"')])]),e._v(" "),n("h4",{attrs:{id:"event-hash-event-def-string"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#event-hash-event-def-string"}},[e._v("#")]),e._v(" "),n("code",[e._v("__EVENT_HASH(<event_def|string>)")])]),e._v(" "),n("p",[e._v("At compile time, the invocation of "),n("code",[e._v("__EVENT_HASH")]),e._v(" is substituted with "),n("code",[e._v("PUSH32 event_hash")]),e._v(", where "),n("code",[e._v("event_hash")]),e._v(" is the selector hash of the passed event definition or string. If a string is passed, it must represent a valid event signature i.e. "),n("code",[e._v('"TestEvent(uint256, address indexed)"')])]),e._v(" "),n("h4",{attrs:{id:"error-error-def"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#error-error-def"}},[e._v("#")]),e._v(" "),n("code",[e._v("__ERROR(<error_def>)")])]),e._v(" "),n("p",[e._v("At compile time, the invocation of "),n("code",[e._v("__ERROR")]),e._v(" is substituted with "),n("code",[e._v("PUSH32 error_selector")]),e._v(", where "),n("code",[e._v("error_selector")]),e._v(" is the left-padded 4 byte error selector of the passed error definition.")]),e._v(" "),n("h4",{attrs:{id:"rightpad-literal"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rightpad-literal"}},[e._v("#")]),e._v(" "),n("code",[e._v("__RIGHTPAD(<literal>)")])]),e._v(" "),n("p",[e._v("At compile time, the invocation of "),n("code",[e._v("__RIGHTPAD")]),e._v(" is substituted with "),n("code",[e._v("PUSH32 padded_literal")]),e._v(", where "),n("code",[e._v("padded_literal")]),e._v(" is the right padded version of the passed literal.")]),e._v(" "),n("h4",{attrs:{id:"codesize-macro-function"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#codesize-macro-function"}},[e._v("#")]),e._v(" "),n("code",[e._v("__codesize(MACRO|FUNCTION)")])]),e._v(" "),n("p",[e._v("Pushes the code size of the macro or function passed to the stack.")]),e._v(" "),n("h4",{attrs:{id:"tablestart-table-and-tablesize-table"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tablestart-table-and-tablesize-table"}},[e._v("#")]),e._v(" "),n("code",[e._v("__tablestart(TABLE)")]),e._v(" and "),n("code",[e._v("__tablesize(TABLE)")])]),e._v(" "),n("p",[e._v("These functions related to Jump Tables are described in the next section.")]),e._v(" "),n("h4",{attrs:{id:"example-7"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-7"}},[e._v("#")]),e._v(" Example")]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v("// Define a function\n#define function test1(address, uint256) nonpayable returns (bool)\n#define function test2(address, uint256) nonpayable returns (bool)\n\n// Define an event\n#define event TestEvent1(address, uint256)\n#define event TestEvent2(address, uint256)\n\n#define macro TEST1() = takes (0) returns (0) {\n    0x00 0x00                // [address, uint]\n    __EVENT_HASH(TestEvent1) // [sig, address, uint]\n    0x00 0x00                // [mem_start, mem_end, sig, address, uint]\n    log3                     // []\n}\n\n#define macro TEST2() = takes (0) returns (0) {\n    0x00 0x00                // [address, uint]\n    __EVENT_HASH(TestEvent2) // [sig, address, uint]\n    0x00 0x00                // [mem_start, mem_end, sig, address, uint]\n    log3                     // []\n}\n\n#define macro MAIN() = takes (0) returns (0) {\n    // Identify which function is being called.\n    0x00 calldataload 0xE0 shr\n    dup1 __FUNC_SIG(test1) eq test1 jumpi\n    dup1 __FUNC_SIG(test2) eq test2 jumpi\n\n    // Revert if no function matches\n    0x00 0x00 revert\n\n    test1:\n        TEST1()\n\n    test2:\n        TEST2()\n}\n")])])]),n("h2",{attrs:{id:"jump-tables"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jump-tables"}},[e._v("#")]),e._v(" Jump Tables")]),e._v(" "),n("p",[e._v("Jump Tables are a convenient way to create switch cases in your\nHuff contracts. Each jump table consists of jumpdest program counters (PCs), and it is\nwritten to your contract's bytecode. These jumpdest PCs can be codecopied\ninto memory, and the case can be chosen by finding a jumpdest at a particular\nmemory pointer (i.e. 0x00 = case 1, 0x20 = case 2, etc.). This allows for a\nsingle jump rather than many conditional jumps.")]),e._v(" "),n("p",[e._v("There are two different kinds of Jump Tables in Huff: "),n("code",[e._v("Regular")]),e._v(" and\n"),n("code",[e._v("Packed")]),e._v(". Regular Jump Tables store jumpdest PCs as full 32 byte\nwords, and packed Jump Tables store them each as 2 bytes. Therefore,\npacked jumptables are cheaper to copy into memory, but they are more\nexpensive to pull a PC out of due to the bitshifting required. The\nopposite is true for Regular Jump Tables.")]),e._v(" "),n("p",[e._v("There are two builtin functions related to jumptables.")]),e._v(" "),n("h4",{attrs:{id:"tablestart-table"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tablestart-table"}},[e._v("#")]),e._v(" "),n("code",[e._v("__tablestart(TABLE)")])]),e._v(" "),n("p",[e._v("Pushes the program counter (PC) of the start of the table passed to the stack.")]),e._v(" "),n("h4",{attrs:{id:"tablesize-table"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tablesize-table"}},[e._v("#")]),e._v(" "),n("code",[e._v("__tablesize(TABLE)")])]),e._v(" "),n("p",[e._v("Pushes the code size of the table passed to the stack.")]),e._v(" "),n("h4",{attrs:{id:"example-8"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-8"}},[e._v("#")]),e._v(" Example")]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v("// Define a function\n#define function switchTest(uint256) pure returns (uint256)\n\n// Define a jump table containing 4 pcs\n#define jumptable SWITCH_TABLE {\n    jump_one jump_two jump_three jump_four\n}\n\n#define macro SWITCH_TEST() = takes (0) returns (0) {\n    // Codecopy jump table into memory @ 0x00\n    __tablesize(SWITCH_TABLE)   // [table_size]\n    __tablestart(SWITCH_TABLE)  // [table_start, table_size]\n    0x00\n    codecopy\n\n    0x04 calldataload           // [input_num]\n\n    // Revert if input_num is not in the bounds of [0, 3]\n    dup1                        // [input_num, input_num]\n    0x03 lt                     // [3 < input_num, input_num]\n    err jumpi                       \n\n    // Regular jumptables store the jumpdest PCs as full words,\n    // so we simply multiply the input number by 32 to determine\n    // which label to jump to.\n    0x20 mul                    // [0x20 * input_num]\n    mload                       // [pc]\n    jump                        // []\n\n    jump_one:\n        0x100 0x00 mstore\n        0x20 0x00 return\n    jump_two:\n        0x200 0x00 mstore\n        0x20 0x00 return\n    jump_three:\n        0x300 0x00 mstore\n        0x20 0x00 return\n    jump_four:\n        0x400 0x00 mstore\n        0x20 0x00 return\n    err:\n        0x00 0x00 revert\n}\n\n#define macro MAIN() = takes (0) returns (0) {\n    // Identify which function is being called.\n    0x00 calldataload 0xE0 shr\n    dup1 __FUNC_SIG(switchTest) eq switch_test jumpi\n\n    // Revert if no function matches\n    0x00 0x00 revert\n\n    switch_test:\n        SWITCH_TEST()\n}\n")])])]),n("h2",{attrs:{id:"code-tables"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#code-tables"}},[e._v("#")]),e._v(" Code Tables")]),e._v(" "),n("p",[e._v("Code Tables contain raw bytecode. The compiler places the code within\nthem at the end of the runtime bytecode, assuming they are referenced\nsomewhere within the contract.")]),e._v(" "),n("h4",{attrs:{id:"example-9"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-9"}},[e._v("#")]),e._v(" Example")]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v("#define table CODE_TABLE {\n    0x604260005260206000F3\n}\n")])])]),n("h2",{attrs:{id:"huff-tests"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#huff-tests"}},[e._v("#")]),e._v(" Huff Tests")]),e._v(" "),n("p",[e._v("The compiler includes a simple, stripped-down testing framework to assist in creating assertions\nas well as gas profiling macros and functions. huff-rs’ test suite is intentionally lacking in features,\nand with that, this addition is not meant to replace developers’ dependency on "),n("code",[e._v("foundry-huff")]),e._v(". Ideally,\nfor contracts that will be in production, Huff developers will utilize both foundry and Huff tests.\nIf you are one of many who uses Huff as a tool for learning, Huff tests can also be a lighter weight\nexperience when testing your contract’s logic.")]),e._v(" "),n("p",[e._v("Tests can be ran via the CLI's "),n("code",[e._v("test")]),e._v(" subcommand. For more information, see the "),n("RouterLink",{attrs:{to:"/resources/cli/"}},[e._v("CLI Resources")]),e._v(".")],1),e._v(" "),n("h3",{attrs:{id:"decorators"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#decorators"}},[e._v("#")]),e._v(" Decorators")]),e._v(" "),n("p",[e._v("The transaction environment for each test can be modified with a decorator. Decorators sit directly above\ntests, and are formatted as follows: "),n("code",[e._v("#[flag_a(inputs...), flag_b(inputs...)]")])]),e._v(" "),n("p",[e._v("Available decorators include:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("calldata")]),e._v(" - Set the calldata for the transaction environment. Accepts a single string of calldata bytes.")]),e._v(" "),n("li",[n("code",[e._v("value")]),e._v(" - Set the callvalue for the transaction environment. Accepts a single literal.")])]),e._v(" "),n("h4",{attrs:{id:"example-10"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-10"}},[e._v("#")]),e._v(" Example")]),e._v(" "),n("div",{staticClass:"language-plaintext extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plaintext"}},[n("code",[e._v('#include "huffmate/utils/Errors.huff"\n\n#define macro ADD_TWO() = takes (2) returns (1) {\n    // Input Stack:  [a, b]\n    add           // [a + b]\n    // Return Stack: [a + b]\n}\n\n#[calldata("0x0000000000000000000000000000000000000000000000000000000000000001"), value(0x01)]\n#define test MY_TEST() = {\n    0x00 calldataload   // [0x01]\n    callvalue           // [0x01, 0x01]\n    eq ASSERT()\n}\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);